package comp2402a2;

import java.util.AbstractList;

/**
 * An implementation of the List interface that allows for fast modifications at
 * both the head and tail.
 * 
 * @param <T>
 *            the type of objects stored in this list
 */
public class ArrayDeque2<T> extends AbstractList<T> {
	/**
	 * The class of elements stored in this queue
	 */
	protected Factory<T> f;
	
	// The following are made public on purpose - for testing purposes
	
	/**
	 * Array used to store elements
	 */
	public T[] a;
	
	/**
	 * Index of next element to de-queue
	 */
	public int j;
	
	/**
	 * Number of elements in the queue
	 */
	public int n;
	
	/**
	 * Grow the internal array
	 */
	protected void resize() {
		
		// T[] b = f.newArray(Math.max(1, n*2));
		// System.arraycopy(a, 0, b, 0, j - 1);
		// System.arraycopy(a, j, b, j + a.length, a.length - j);
		//
		// a = b;
		
		T[] b = f.newArray(Math.max(2 * n, 1));
		for (int k = 0; k < n; k++) {
			// b[k] = a[(j+k) mod a.length];
			// b[k] = a[(j+k) - ( (j+k) / a.length * a.length )];
			b[k] = a[mod(j + k, a.length)];
			
		}
		a = b;
		j = 0;
		
		System.out.println("resize");
	}
	
	/**
	 * Constructor
	 */
	public ArrayDeque2(Class<T> t) {
		f = new Factory<T>(t);
		a = f.newArray(1);
		j = 0;
		n = 0;
	}
	
	@Override
	public int size() {
		return n;
	}
	
	@Override
	public T get(int i) {
		if (i < 0 || i > n - 1) {
			throw new IndexOutOfBoundsException();
		}
		
		return a[mod(j + i, a.length)]; // look, no mod
	}
	
	@Override
	public T set(int i, T x) {
		if (i < 0 || i > n - 1) {
			throw new IndexOutOfBoundsException();
		}
		T y = a[mod(j + i, a.length)]; // look, no mod
		a[mod(j + i, a.length)] = x;
		return y;
	}
	
	@Override
	public void add(int i, T x) {
		// TODO: modify this to avoid running off either end
		if (i < 0 || i > n) { // XXX remove >= if shitty
			throw new IndexOutOfBoundsException();
		}
		if (n + 1 > a.length) {
			resize();
		}
		if (i < n / 2) { // shift a[0],..,a[i-1] left one position
			j = (j == 0) ? a.length - 1 : j - 1; // (j-1) mod a.length
			for (int k = 0; k <= i - 1; k++) {
				a[mod(j + k, a.length)] = a[mod(j + k + 1, a.length)];
			}
		} else { // shift a[i],..,a[n-1] right one position
			for (int k = n; k > i; k--) {
				a[mod(j + k, a.length)] = a[mod(j + k - 1, a.length)];
			}
		}
		if (a.length < j + i) {
			a[j + i - a.length] = x;
		} else {
			a[j + i] = x;
		}
		n++;
	}
	
	@Override
	public T remove(int i) {
		if (i < 0 || i > n - 1) {
			throw new IndexOutOfBoundsException();
		}
		T x = get(i);
		if (i < n / 2) { // shift a[0],..,[i-1] right one position
			for (int k = i; k > 0; k--) {
				a[mod(j + k, a.length)] = a[mod(j + k - 1, a.length)];
			}
			
			j = mod(j + 1, a.length);
		} else { // shift a[i+1],..,a[n-1] left one position
			for (int k = i; k < n - 1; k++) {
				a[mod(j + k, a.length)] = a[mod(j + k + 1, a.length)];
				
			}
		}
		n--;
		if (3 * n < a.length) {
			resize();
		}
		return x;
	}
	
	@Override
	public void clear() {
		n = 0;
		resize();
	}
	
	public int mod(int x, int y) {
		return x - (x / y * y);
	}
	
	public void printArray() {
		
		System.out.print("n" + n + " a" + a.length + " j" + j + " ");
		
		for (int i = 0; i < a.length; i++) {
			System.out.print((a[i] == null ? 'x' : a[i]) + ",");
		}
		System.out.print("\n");
	}
	
	public static void main(String[] args) {
		
		ArrayDeque2<Integer> l = new ArrayDeque2<Integer>(Integer.class);
		
		for (int i = 0; i < 9; i++) {
			l.add(i);
			l.printArray();
		}
		
		for (int i = 0; i < 5; i++) {
			l.remove(3);
			l.printArray();
		}
		
	}
}
